# 练习 Go 进阶过程部分笔记

学习链接

- [Golang 标准库文档](https://studygolang.com/pkgdoc)
- [深入解析Go](https://tiancaiamao.gitbooks.io/go-internals/content/zh/)
- [Golang 语言情怀](http://doc.golang.ltd/)
- [千锋-Go语言基础进阶](https://www.qfgolang.com/)
- [The-Golang-Standard-Library-by-Example](https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter01/01.0.html)
- [Go by Example 中文版](https://gobyexample-cn.github.io/)

## go中基本数据类型和引用类型

解释Go中各种类型变量在内存中的布局
参考[《深入解析Go》-2.1 基本类型](https://tiancaiamao.gitbooks.io/go-internals/content/zh/02.1.html)

在Go语言中，对于`布尔变量`或`数值类型`或`字符串类型`或`数组`都是按照值传递的：值在传递给函数或者方法时会被复制一份，然后方法或函数使用的是复制的这份值，也就不会对原值产生什么影响。一般情况下，对于布尔变量或数值类型或字符串类型的按值传递是非常廉价的，Go语言编译器会在传递过程中进行安全优化。

参考: [Go语言 值，指针，引用类型](https://www.jianshu.com/p/af42cb368cef)

## 局部变量和全局变量

- 局部变量
  - 一句话总结：可通过花括号来控制变量的作用域，花括号中的变量是单独的作用域，同名变量会覆盖外层。
  - 执行到定义的那句话，开始分配内存空间，离开作用域自动进行释放
  - 函数内定义的变量称为局部变量。
- 全局变量
  - 在函数体外声明的变量称之为全局变量。
  - 全局变量在任何地方都可以进行使用，可以在整个包甚至外部包（被导出后）使用。

- 作用域
  - 作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。

- 不同作用域中，同名变量
  - 不同的作用域，允许定义同名的变量。
  - 使用变量的原则，就近原则，如果局部变量没有，就去全局变量中找。

## 回调函数和闭包

当函数具备以下两种特性的时候，就可以称之为高阶函数(high order functions)：

- 函数可以作为另一个函数的参数(典型用法是回调函数)
- 函数可以返回另一个函数，即让另一个函数作为这个函数的返回值(典型用法是闭包)

闭包

- 累加器变量和地址
- 函数变量地址怎么取
  - 变量区
  - 函数区

代码片段：

- 闭包

```go
package main

import (
    "fmt"
)

// 提供一个值，每次调用函数会指定对值进行累加
func Accumulate(value int) func() int {

    // 返回一个闭包
    return func() int {

      // 累加
      value++

      // 返回一个累加值
      return value
    }
}

func main() {

    // 创建一个累加器，初始值为1
    accumulator := Accumulate(1)

    // 累加1并打印
    fmt.Println(accumulator())

    fmt.Println(accumulator())

    // 打印累加器的函数地址
    fmt.Printf("%p\n", &accumulator)

    // 创建一个累加器，初始值为10
    accumulator2 := Accumulate(10)

    // 累加1并打印
    fmt.Println(accumulator2())

    // 打印累加器的函数地址
    fmt.Printf("%p\n", &accumulator2)
}
```

```go
package main

import "fmt"

//参考：https://www.cnblogs.com/f-ck-need-u/p/9878898.html
// 闭包
func f(x int) func(int) int {
    g := func(y int) int {
      return x + y
    }
    return g
}

func main() {
    var a int
    fmt.Println(a)
    var s struct{
      name string
      age int
    }
    fmt.Printf("%+v\n",s)


    x:=5
    g:=f(x)
    fmt.Println(g(3))


    var y int
    // 这也是一种闭包
    func2:=func(i int)int{
      return y+i
    }
    y=5
    // 调用闭包
    fmt.Println(func2(5))

    y=10
    fmt.Println(func2(5))
    // 之所以这里的func2也是闭包函数，是因为func2中访问了不属于自己的变量y，而这个变量在闭包函数定义时是未绑定值的，也就是自由变量。
    
    // func2:=func(x int) func (int) int{
    // 	g:=func(y int) int {
    // 		return x+y
    // 	}
    // 	return g
    // }
}
```

- 回调函数

```go
package main

import "fmt"

type callBackFunc func (x,y int) int

func main() {
    fmt.Println(callback(1, 2, add))
}

func add(a, b int) int {
    return a + b
}

func callback(a, b int,f callBackFunc) int {
    return f(a, b)
}
```

参考链接:
[Go基础系列：函数(2)——回调函数和闭包](https://www.cnblogs.com/f-ck-need-u/p/9878898.html)

## byte 转 string

将 byte 类型转成了 string 类型

```go
a:='2'
fmt.Println(string(a))
b:='人'
fmt.Println(string(b))
str3:="ddd"
fmt.Printf("%T-%v-%T\n",str3[1],str3[1],string(str3[1]))
```

## 接口的类型转换和断言

在 Golang 中，将一个接口类型转换成另一个接口类型，或者将一个接口转换为另一个基本类型，都必须需要使用类型断言。Go 语言接口类型转换语法：

`value, ok := x.(T)`

其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。

该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：

- 如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。
- 如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。
- 无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。

也可以这么理解：

- 将接口 x 转换成 T 类型。 如果转换成功，返回转换成功后的值，即 value，ok 为 true。如果转换失败，value 为 零值，ok 为 false。Go 语言接口类型转换语法：

`value := x.(T)`

- 将接口 x 转换成 T 类型。 如果转换成功，返回转换成功后的值，即 value，如果转换失败，程序会 panic。

获取接口类型的三种方式

- `%T`
- `switch i:=e.(type)`
- `reflect.TypeOf(e)`

总结

- 接口对象不能调用接口实现对象的属性
- 空接口 `interface{}` 没有定义任何函数，因此 Go 中所有类型都实现了空接口。当一个函数的形参是 `interface{}`，那么在函数中，需要对形参进行断言，从而得到它的真实类型。

以下两个例子及参考链接帮助理解

switch 的高级玩法
**可以用 switch 语句来判断传入变量的类型。**
`x` 是一个未知类型的变量，`switch t := x.(type)` 用这个方式来赋值，`t` 就是有确定类型的变量。

```go
switch t := x.(type) {
case int:
    return t
case float64:
   return int(math.Ceil(t))
}
```

什么叫未知类型？？

这就是 go 中有意思的地方了, `interface{}` 类型，是一种神奇的类型，他可以是任何类型的接口，而具体的类型是实现。

```go
var x interface{}
x = 1
fmt.Println(x)
//输出1
```

所以完整的函数是这样的

```go
func typeSwitchDemo(x interface{}) int {
    switch t := x.(type) {
    case int:
        return t
    case float64:
        return int(math.Ceil(t))
    }
    return 0
}
```

这个东西有什么用呢？？有没有想过如果你有一个场景，你在调用第三方的接口，却发现对方的接口发生了微调，原来的int类型，被转换成了string类型，你必须写出兼容两种方式的代码来解析json。

那么这个时候，type switch 将会是你的武器。

**接口对象不能调用接口实现对象的属性**

```go
package main

import (
    "fmt"
)

// 声明一个解析错误
type ParseError struct {
    Filename string // 文件名
    Line     int    // 行号
}

// 实现error接口，返回错误描述
func (e *ParseError) Error() string {
    return fmt.Sprintf("%s:%d", e.Filename, e.Line)
}

// 创建一些解析错误
func newParseError(filename string, line int) error {
    return &ParseError{filename, line}
}

func main() {

    var e error
    // 创建一个错误实例，包含文件名和行号
    e = newParseError("main.go", 1)
    fmt.Println(e)

    // 通过error接口查看错误描述
    fmt.Println(e.Error())
    // fmt.Println(e.Filename) 接口对象不能调用接口实现对象的属性

    // 根据错误接口具体的类型，获取详细错误信息
    switch detail := e.(type) {
      case *ParseError: // 这是一个解析错误
        fmt.Printf("Filename: %s Line: %d\n", detail.Filename, detail.Line)
      default: // 其他类型的错误
        fmt.Println("other error")
      }
}
```

参考链接：

- [Go语言接口类型转换](https://haicoder.net/golang/golang-interface-case.html)
- [接口的类型和断言](https://www.qfgolang.com/?special=jiekou&pid=1925)‘
- [Go语言类型断言简述](http://c.biancheng.net/view/4281.html)
- [三分钟学 Go 语言——条件语句+switch和type switch](https://zhuanlan.zhihu.com/p/130456325)
- [Go 语言 switch 语句](https://www.runoob.com/go/go-switch-statement.html)

## 嵌入、组合和转发

参考示例代码：[compose_forward_2](./practice_demo/compose_forward_1.go)、[compose_forward_2](./practice_demo/compose_forward_2.go)、[compose_forward_3](./practice_demo/compose_forward_3.go)

以下两个例子结合来看，更易理解：

- [Go结构体嵌入接口类型](https://blog.csdn.net/weixin_34268310/article/details/92645136)
- [Go by Example 中文版: Embedding](https://gobyexample-cn.github.io/embedding)

## WaitGroup

想要等待多个协程完成

参考

- [Go by Example 中文版: WaitGroup](https://gobyexample-cn.github.io/waitgroups)
- [package sync](https://studygolang.com/static/pkgdoc/pkg/sync.htm#WaitGroup.Add)

## 设计模式

- 单例模式
- 工厂模式

## 函数实现接口

实例代码

```go
package main

import (
    "fmt"
)

// 调用器接口
type Invoker interface {
    // 需要实现一个Call方法
    Call(interface{})
  }

// 结构体类型
type Struct struct {
}

// 实现Invoker的Call
func (s *Struct) Call(p interface{}) {
  )
}

// 函数定义为类型
type FuncCaller func(interface{})

// 实现Invoker的Call
func (f FuncCaller) Call(p interface{}) {

    // 调用f函数本体
    f(p)
}

func main() {

    // 声明接口变量
    var invoker Invoker

    // 实例化结构体
    s := new(Struct)

    // 将实例化的结构体赋值到接口
    invoker = s

    // 使用接口调用实例化结构体的方法Struct.Call
    invoker.Call("hello")

    // 将匿名函数转为FuncCaller类型，再赋值给接口
    invoker = FuncCaller(func(v interface{}) {
      fmt.Println("from function", v)
    })

    // 使用接口调用FuncCaller.Call，内部会调用函数本体
    invoker.Call("hello")
}
```

## 结构体初始化

```go
type structDemo struct{
  name string
  age int
}

```

实例的三种方式

- `var s structDemo`
- `new(structDemo)`
- `&structDemo{}`

- 具体用法需要继续学习

## struct 与 json 相互转化

## 源码库

## 判断是否为nil

小技巧，函数传参可能会接收零值，不同类型的变量零值可能为 `nil`，对于一些可能会引发 `panic` 的操作要注意添加一些判断来保护方法（函数）

哪些情况需要加还需要继续总结，多看官方文档、源码库

```go
type person struct{
    age int
}

func (p *person) birthday()  {
    // 判断是否为nil保护方法
    if p == nil{
        return
    }
    // struct 指针自动解引用
    // 使用点语法访问其内对应字段即可
    p.age++
}
```

## 类型别名和类型定义

Golang语言中存在一个关键字type，type又有两种使用方式，一种是类型别名，一种是类型定义

- 类型定义

```go

type Student struct{
  name string
  age int
}

type teacher Student

```

- 类型别名

```go
type stu=Student

type myInt=int

```

区别就是类型定义是完全定义了一种新的类型，而类型别名只是给现有的类型取了一个别名alias

```go
type I int
type D = int
```

拿上面的例子来说，I是一种全新的类型，和现有的int类型完全不一样，即I类型的指针不能指向int类型的指针，反之亦然，类似于C语言中的typedef。而D只是int的一个别名，相当于编译期会预处理替换为int，类似于C语言中的#define。

再看一个例子

```go
type Student struct {
  name String
  age int
}

type Teacher Student
```

相当于定义了一个新的Teacher类型，和下面的代码是等价的。虽然两个类型内存布局完全一样，但是从概念上来说，他们是完全不同的两个类型，不能相互兼容。

```go
type Teacher struct {
  name String
  age int
}
```

类型别名这个功能非常有用，鉴于go中有些类型写起来非常繁琐，比如json相关的操作中，经常用到map[string]interface {}这种类型，写起来是不是很繁琐，没关系，给它起个简单的别名!这样用起来爽多了。

`type strMap2Any = map[string]interface {}`

打印类型别名和类型定义各自的类型以展示区别

```go
package main
import (
    "fmt"
)
// 将NewInt定义为int类型
type NewInt int
// 将int取一个别名叫IntAlias
type IntAlias = int
func main() {
    // 将a声明为NewInt类型
    var a NewInt
    // 查看a的类型名
    fmt.Printf("a type: %T\n", a)
    // 将a2声明为IntAlias类型
    var a2 IntAlias
    // 查看a2的类型名
    fmt.Printf("a2 type: %T\n", a2)
}
 
 
代码运行结果：
a type: main.NewInt
a2 type: int
```

引用 [Go——类型别名和类型定义](https://blog.csdn.net/m0_37965811/article/details/117551823)

## string

string和切片（`[]byte`、`[]rune`）的相互转换

string的遍历两种方式

- len() 按字节
- range 按字符

字符串长度计算

- 按字节数 len()
- 按字符数 RuneCountInString()

[Go语言字符串](http://c.biancheng.net/view/17.html)

## len函数

`func len(V Type) int`

len函数是Go语言中的内置函数,其作用是用于计算数组(包括数组指针)、切片(slice)、map、channel、字符串等数据类型的长度，注意，结构休(struct)、整型布尔等不能作为参数传给len函数。

- 数组或数组指针：返回元素个数

- map和slice: 元素个数

- channel:通道中未读的元素个数

- 字符串：字节数，并非字符串的字符数

- 当V的值为nil值，len返回0

```go
 
sl := make([]int,0)
sl = nil
if sl == nil{
    fmt.Println(len(sl)) //当slice类型为nil时，输出0
}
 
s := "欢迎学习Go的len()函数"//14个字符
 
fmt.Println(len(s))//输出28(UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。)

```

在处理字符串时，经常需要知道字符串的字符数，但len()只计算字符串字节数，因此我们可以自定义处理字符串个数的函数。

```go
//rune是32位的int别外，可以代表一个unicode字符，因此，通过将字符串将成rune类型的切片，切片元素个数代表字符个数
func count(str string) int {
    r := []rune(str)
    // count:=0
    // for _:=range str{
        // count++
    // }
    return len(r)
}
 
s := "欢迎学习Go的len()函数"//14个字符
 
fmt.Println(count(s))//14
 
fmt.Println(len(s))//28

```

参考

- [Golang学习笔记(十七)：len函数](https://blog.csdn.net/weixin_33913377/article/details/91405145)
- [字节、字符和位的关系](https://github.com/Harderboy/Internship-Notes/blob/main/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E8%8A%82-%E5%AD%97%E7%AC%A6-%E4%BD%8D%E7%9A%84%E5%85%B3%E7%B3%BB.md)

## 键盘输入

- [ ] 待练习

- [Go基础系列：读取标准输入](https://www.cnblogs.com/f-ck-need-u/p/9944229.html)
- [go语言--输入输出](https://blog.csdn.net/qq_39913441/article/details/100126339)

## context 库用法

- [ ] 待实践后继续补充

- [深度解密Go语言之context](https://zhuanlan.zhihu.com/p/68792989)
- [Go语言Context（上下文）](http://c.biancheng.net/view/5714.html)
- [深入理解Golang之context](https://zhuanlan.zhihu.com/p/110085652)
- [Go by Example 中文版: Context](https://gobyexample-cn.github.io/context)
- [Golang 中 context（上下文）使用](https://blog.csdn.net/finghting321/article/details/106012673)

## make和new

[Go语言make和new关键字的区别及实现原理](http://c.biancheng.net/view/5722.html)

## select

- [Go 语言 select 语句](https://www.runoob.com/go/go-select-statement.html)
- [golang channel关闭后，是否可以读取剩余的数据](https://blog.csdn.net/lanyang123456/article/details/98378982)
- [理解 Go 语言中的 select 用法](https://zhuanlan.zhihu.com/p/256950290)
- [go语言学习-chan使用过程关于close()](https://www.jianshu.com/p/eb1a9b316f05)
- [“通道写完后，必须关闭通道，否则range遍历会出现死锁”这句话对吗？](https://segmentfault.com/q/1010000018071961)
- [Go 通道（chan）关闭和后续读取操作](https://blog.csdn.net/Tovids/article/details/77867284)
- [golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？](https://zhuanlan.zhihu.com/p/159258142)

## switch

[Go语言switch case语句](http://c.biancheng.net/view/48.html)

## 单元测试

参考：

[Go Test 单元测试简明教程](https://geektutu.com/post/quick-go-test.html)

## 继续学习

- Golang 中的 bufio.Scanner
- map

```go

func main() {
    counts := make(map[string]int)
    input := bufio.NewScanner(os.Stdin)
    for input.Scan() {
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}
```

- make和new继续理解
- go by example 这执行进程等和操作系统交互的命令、信号、死锁
- CSP
- 变量逃逸
- GC、GMP
- [GC](https://blog.csdn.net/weixin_44879611/article/details/105373079?utm_source=app&app_version=4.16.0)
- [Golang修养必经之路](https://www.kancloud.cn/aceld/golang/1958303)
- [Go语言map底层浅析](https://segmentfault.com/a/1190000018380327)

- slice底层和扩容策略[深入解析 Go 中 Slice 底层实现](https://halfrost.com/go_slice/)
- map底层[Map实现原理](https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/Map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html)、[Go语言map底层浅析](https://segmentfault.com/a/1190000018380327)
- channel实现原理[深入详解Go的channel底层实现原理【图解】](https://cloud.tencent.com/developer/article/1750350)

## websocket

- [3.1 - WebSocket（上）](https://www.bilibili.com/video/BV1Cf4y1K7Ht?spm_id_from=333.337.search-card.all.click)
- [Golang 使用 Websocket 教程](https://zhuanlan.zhihu.com/p/455635795)
- [使用Go语言创建WebSocket服务](https://segmentfault.com/a/1190000022034813)

## rpc

- [ ] 原理
- [ ] 和http区别
- [ ] 基本使用 + Demo
